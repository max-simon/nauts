package e2e

import (
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/nats-io/nats.go"
)

type TestEnv struct {
	t         *testing.T
	mode      string
	baseDir   string
	natsCmd   *exec.Cmd
	nautsCmd  *exec.Cmd
	port      int
	credsFile string // sentinel creds for operator mode
}

func newTestEnv(t *testing.T, dir string, mode string, port int) *TestEnv {
	t.Helper()

	baseDir := filepath.Join(".", dir)
	if _, err := os.Stat(baseDir); os.IsNotExist(err) {
		t.Fatalf("test directory %s does not exist", baseDir)
	}

	env := &TestEnv{
		t:       t,
		mode:    mode,
		baseDir: baseDir,
		port:    port,
	}

	if mode == "operator" {
		env.credsFile = filepath.Join(baseDir, "dummy.creds")
	}

	return env
}

func (e *TestEnv) start() {
	e.t.Helper()

	// Clean up JetStream storage
	// We use a convention where the store dir is /tmp/nauts-test-<dir>-jetstream
	// e.g. /tmp/nauts-test-policy-static-jetstream
	// This must match the configuration generated by setup.sh in the respective directories.
	jsDir := fmt.Sprintf("/tmp/nauts-test-%s-jetstream", filepath.Base(e.baseDir))
	if err := os.RemoveAll(jsDir); err != nil {
		e.t.Logf("Warning: failed to clean up jetstream dir %s: %v", jsDir, err)
	}

	// Start NATS server
	e.t.Log("Starting NATS server...")
	e.natsCmd = exec.Command("nats-server", "-c", "nats-server.conf", "-p", fmt.Sprintf("%d", e.port))
	e.natsCmd.Dir = e.baseDir
	if err := e.natsCmd.Start(); err != nil {
		e.t.Fatalf("Failed to start NATS server: %v", err)
	}

	// Wait for NATS to be ready
	time.Sleep(time.Second)

	// Start nauts auth service
	e.t.Log("Starting nauts auth service...")
	// environment variable NATS_URL
	e.nautsCmd = exec.Command("../../bin/nauts", "serve", "-c", "nauts.json")
	e.nautsCmd.Env = []string{fmt.Sprintf("NATS_URL=nats://localhost:%d", e.port)}
	e.nautsCmd.Dir = e.baseDir
	e.nautsCmd.Stdout = os.Stdout
	e.nautsCmd.Stderr = os.Stderr
	if err := e.nautsCmd.Start(); err != nil {
		e.stopNats()
		e.t.Fatalf("Failed to start nauts: %v", err)
	}

	// Wait for nauts to be ready
	time.Sleep(time.Second)
}

func (e *TestEnv) stop() {
	e.t.Helper()

	if e.nautsCmd != nil && e.nautsCmd.Process != nil {
		e.nautsCmd.Process.Kill()
		e.nautsCmd.Wait()
	}
	e.stopNats()

	// Wait for cleanup
	time.Sleep(500 * time.Millisecond)
}

func (e *TestEnv) stopNats() {
	if e.natsCmd != nil && e.natsCmd.Process != nil {
		e.natsCmd.Process.Kill()
		e.natsCmd.Wait()
	}
}

func (e *TestEnv) ConnectWithUsernameAndPassword(username string, password string, account string, providerID string) (*nats.Conn, error) {
	innerToken := username
	if password != "" {
		innerToken += ":" + password
	}
	// only add ap to json if given
	apOpt := ""
	if providerID != "" {
		apOpt = fmt.Sprintf(`,"ap":%q`, providerID)
	}
	tokenJson := fmt.Sprintf(`{"account":%q,"token":%q%s}`, account, innerToken, apOpt)

	opts := []nats.Option{
		nats.Name(fmt.Sprintf("nauts-e2e-%s", username)),
		nats.Token(tokenJson),
		nats.Timeout(2 * time.Second),
		nats.CustomInboxPrefix(fmt.Sprintf("_INBOX_%s", username)),
	}

	if e.credsFile != "" {
		opts = append(opts, nats.UserCredentials(e.credsFile))
	}

	return nats.Connect(fmt.Sprintf("nats://localhost:%d", e.port), opts...)
}

func (e *TestEnv) ConnectWithJwt(token string, account string, providerID string) (*nats.Conn, error) {
	apOpt := ""
	if providerID != "" {
		apOpt = fmt.Sprintf(`,"ap":%q`, providerID)
	}
	tokenJson := fmt.Sprintf(`{"account":%q,"token":%q%s}`, account, token, apOpt)

	opts := []nats.Option{
		nats.Name(fmt.Sprintf("nauts-e2e-test-jwt-%s", account)),
		nats.Token(tokenJson),
		nats.Timeout(2 * time.Second),
		nats.CustomInboxPrefix(fmt.Sprintf("_INBOX_%s", account)),
	}

	if e.credsFile != "" {
		opts = append(opts, nats.UserCredentials(e.credsFile))
	}

	return nats.Connect(fmt.Sprintf("nats://localhost:%d", e.port), opts...)
}

func (e *TestEnv) GenerateJWT(t *testing.T, roles []string, sub string) string {
	keyPath := filepath.Join("common", "rsa.key")
	keyBytes, err := os.ReadFile(keyPath)
	if err != nil {
		t.Fatalf("failed to read private key: %v", err)
	}

	// Parse PEM
	block, _ := pem.Decode(keyBytes)
	if block == nil {
		t.Fatalf("failed to parse PEM block")
	}

	// Parse Key (PKCS8 in the python script)
	privKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err != nil {
		t.Fatalf("failed to parse private key: %v", err)
	}

	now := time.Now()
	claims := jwt.MapClaims{
		"iss": "e2e",
		"sub": sub,
		"iat": now.Unix(),
		"exp": now.Add(time.Hour).Unix(),
		"nauts": map[string]interface{}{
			"roles": roles,
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	signed, err := token.SignedString(privKey)
	if err != nil {
		t.Fatalf("failed to sign token: %v", err)
	}
	return signed
}

// GenerateAwsSigV4Token generates an AWS SigV4 token by calling the helper script
// that uses AWS CLI to create a signed GetCallerIdentity request.
// Returns a JSON token with {authorization, date, securityToken}.
func (e *TestEnv) GenerateAwsSigV4Token(t *testing.T, profile string) string {
	t.Helper()

	// baseDir is like "./connection-static", so go up to e2e dir, then to common
	scriptPath := filepath.Join("..", "common", "generate-aws-token.sh")
	cmd := exec.Command(scriptPath, profile)
	cmd.Dir = e.baseDir

	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("failed to generate AWS SigV4 token: %v\nOutput: %s", err, string(output))
	}

	// Output should be JSON token
	token := string(output)
	// Trim whitespace
	for len(token) > 0 && (token[0] == ' ' || token[0] == '\n' || token[0] == '\r' || token[0] == '\t') {
		token = token[1:]
	}
	for len(token) > 0 && (token[len(token)-1] == ' ' || token[len(token)-1] == '\n' || token[len(token)-1] == '\r' || token[len(token)-1] == '\t') {
		token = token[:len(token)-1]
	}

	if token == "" || token[0] != '{' {
		t.Fatalf("invalid AWS SigV4 token output: %s", string(output))
	}

	return token
}

// ConnectWithAwsSigV4 connects to NATS using AWS SigV4 authentication.
// The token parameter is expected to be a JSON string like:
// {"authorization":"...","date":"...","securityToken":"..."}
func (e *TestEnv) ConnectWithAwsSigV4(token string, account string, providerID string) (*nats.Conn, error) {
	// Escape the token JSON for embedding in outer JSON
	// token is already a JSON string, so we need to escape it as a string value
	apOpt := ""
	if providerID != "" {
		apOpt = fmt.Sprintf(`,"ap":%q`, providerID)
	}

	// Embed the token JSON string as a string (not parse it)
	tokenJson := fmt.Sprintf(`{"account":%q,"token":%q%s}`, account, token, apOpt)

	opts := []nats.Option{
		nats.Name(fmt.Sprintf("nauts-e2e-test-aws-%s", account)),
		nats.Token(tokenJson),
		nats.Timeout(2 * time.Second),
		nats.CustomInboxPrefix(fmt.Sprintf("_INBOX_%s", account)),
	}

	if e.credsFile != "" {
		opts = append(opts, nats.UserCredentials(e.credsFile))
	}

	return nats.Connect(fmt.Sprintf("nats://localhost:%d", e.port), opts...)
}

func SubscribeSyncWithCheck(nc *nats.Conn, subject string) (*nats.Subscription, error) {
	errCh := make(chan error, 1)
	nc.SetErrorHandler(func(_ *nats.Conn, _ *nats.Subscription, err error) {
		select {
		case errCh <- err:
		default:
		}
	})
	sub, err := nc.SubscribeSync(subject)
	if err != nil {
		return nil, err
	}
	if err := nc.Flush(); err != nil {
		return nil, err
	}
	// small timeout to account for client library processing loop latency
	select {
	case err := <-errCh:
		return nil, err
	case <-time.After(50 * time.Millisecond):
		return sub, nil
	}
}

// PublishSync performs a synchronous publish, waiting for any async errors
// from the server (like permission violations).
func PublishSync(nc *nats.Conn, subject string, data []byte) error {
	errCh := make(chan error, 1)
	nc.SetErrorHandler(func(_ *nats.Conn, _ *nats.Subscription, err error) {
		select {
		case errCh <- err:
		default:
		}
	})
	if err := nc.Publish(subject, data); err != nil {
		return err
	}
	if err := nc.Flush(); err != nil {
		return err
	}
	// small timeout to account for client library processing loop latency
	select {
	case err := <-errCh:
		return err
	case <-time.After(50 * time.Millisecond):
		return nil
	}
}

func WithTestEnv(t *testing.T, dir string, mode string, port int, fn func(t *testing.T, env *TestEnv)) {
	t.Helper()
	env := newTestEnv(t, dir, mode, port)
	env.start()
	defer func() {
		env.stop()
	}()
	time.Sleep(2 * time.Second)
	fn(t, env)
}
